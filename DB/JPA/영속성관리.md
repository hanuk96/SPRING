## 영속성 관리

- Entity Manager : 엔티티를 관리하는 관리자이다. 
- Factory의 경우 여러 스레드가 동시에 접근해도 안전하여 스레드간 공유가 가능하지만 Manager의 경우에는 동시성 문제가 발생하므로 공유가 불가능하다
- Entity Manager는 Connection이 필요할때까지 Connection을 얻지않는다



- **영속성 컨텍스트** : 엔티티를 영구 저장하는 환경, 엔티티 매니저를 통해서 관리한다
- JPA는 트랜잭션을 커밋하게되면 영속성 컨텍스트를 플러시하게된다
- 플러쉬 : 영속성 컨텍스트의 내용을 데이터베이스에 적용하는 작업
- 영속성 컨텍스트 삽입과정

![image](https://user-images.githubusercontent.com/12428689/153410310-2f3307bc-be77-4f45-b315-29bbcb45b35e.png)


- JPA의 장점
  - 쓰기지연이 가능하다 : 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 하는 작업, commit을 진행할때에 한번에 데이터베이스에 sql을 전달함
  - 수정에대한 변경감지 : update함수를 따로 쓰지않는다. 그 이유는 commit을 진행할때(플러시 상황) 영속성 컨텍스트에 올라온 엔티티와 캐시에 올라온 스냅샷을 비교하여 수정여부를 비교하기때문
  - 기본적으로 수정시에 jpa는 모든필드를 업데이트하여 수정하게된다, 일부만 수정하기 위해서는 dynamicupdate(하이버네이트) 확장기능을 사용하면 된다 - 컬럼이 30개 이상일때 효과있음



- 플러시 : 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다
  - em.flush를 이용해 직접 컨텍스트에서 데이터베이스로 반영
  - 트랜잭션 commit 실행시 플러시가 자동 호출
  - JPQL 쿼리 실행 시 플러시가 자동 호출

- 플러시를 할때 영속성 컨텍스트에 보관된 엔티티들을 지운다고 생각하면 x
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는것뿐임



- 준영속 상태 : 영속성 컨텍스트가 제공하는 기능을 이용할 수 없다
  - entity manager의 detach 함수를 이용 - 특정 엔티티 하나
  - clear, close 함수를 이용 - 모든 엔티티

- 영속성 컨텍스트, 캐시와 쓰기 지연 sql 저장소에 있는 detach한 엔티티의 모든 sql 정보를 지운다
- merge 함수를 통해 준영속 상태의 엔티티를 다시 영속 상태의 엔티티로 변경할 수 있다



정리

- 영속성 컨텍스트는 Application과 DB사이에서 객체를 보관하는 가상의 DB 같은 역할을 한다
  - 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩 기능을 사용할 수 있다

- 엔티티 매니저 팩토리에 의해서 엔티티 매니저를 생성한다
  - 각자의 엔티티 매니저는 스레드간 공간이 독립적임
  - 엔티티 매니저를 만들면 내부에 영속성 컨텍스트도 같이 생성
- 영속성 컨텍스트에 저장한 엔티티는 **플러시** 시점에 DB에 저장이 된다
  - 보통 트랜잭션을 commit 할때 플러시 된다
